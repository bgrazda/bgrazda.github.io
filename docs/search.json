[
  {
    "objectID": "delete-later/practice.html",
    "href": "delete-later/practice.html",
    "title": "Here is my level one header",
    "section": "",
    "text": "Here is my level one header\nHere is my first paragraph\nHere is my second paragraph, where you can read more about MEDS.\nThis is very important text!"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Blog",
    "section": "",
    "text": "Environmental Impacts of the 2017 Thomas Fire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Brooke Grazda",
    "section": "",
    "text": "Hi! My name is Brooke Grazda. I am a San Diego native currently based in Santa Barbara, California. I am an environmental data scientist focused on using programming tools to help inform the efficacy of environmental policy. Keep reading for a little bit more about me!\nI am currently a Masters of Environmental Data Science student at the Bren School of Environmental Science & Management. Previously, I graduated from UC Santa Barbara (UCSB) with a Bachelor of Arts in Environmental Studies and a minor in Applied Psychology. While taking interdisciplinary coursework in food, water, and energy, I struggled to narrow down my interests into one singular niche. Rather, I understood that I was passionate about applying technical skills to environmental problem solving with natural resources.\nDuring my undergrad, I worked at the Institute for Energy Efficiency (IEE) at UCSB as an administrative and marketing student assistant. At IEE, I became fascinated by all the different applications of STEM research to increase energy efficiency. The importance of science communication in combating the climate crisis stood out to me significantly. I was curious to figure out ways to bridge the gap between technical science jargon and the general publicâ€™s understanding of environmental solutions. In many instances, data science seemed to be my answer.\nI studied tropical biology and conservation while abroad in Costa Rica, and conducted an independent research project. My research project collected and analyzed the threatened behaviors of reef fish located in the Cuajiniquil Bay, and was a catalyst for pursuing environmental data science.\nPrior to starting my graduate program, I worked in my hometown as an environmental educator at a local nonprofit, I Love A Clean San Diego. Here, I resonated deeply with their mission of waste reduction, outreach, and conservation.\nI am committed to use data driven solutions to educate the public and effectively manage natural resources. I am currently an Environmental Resources Management Intern at the County of Santa Barbara Public Works Department in the Resource Recovery & Waste Management Division. My long term goals are to use data science as a tool to inform policy and advocate for environmental justice. Check out some of my projects!"
  },
  {
    "objectID": "posts/thomas-fire-exercises.html#exercise-1-visualizing-aqi-during-the-2017-thomas-fire-in-santa-barbara-county",
    "href": "posts/thomas-fire-exercises.html#exercise-1-visualizing-aqi-during-the-2017-thomas-fire-in-santa-barbara-county",
    "title": "Environmental Impacts of the 2017 Thomas Fire",
    "section": "Exercise 1: Visualizing AQI during the 2017 Thomas Fire in Santa Barbara County",
    "text": "Exercise 1: Visualizing AQI during the 2017 Thomas Fire in Santa Barbara County\nAbout: The Thomas Fire was the largest wildifre that California had seen at the time. It expanded and scorched 281,893 acres across Santa Barbara and Ventura Counties, and had imemdiate impacts on air quality and existing habitat. This analysis aims to visualize the impacts and spread of the Thomas Fire utilizing the pandas library, practicing with subsetting values related to AQI.\nHighlights: This analysis practices important techniques such as joining dataframes in pandas using the concat() function. This allows us to aggregate two data frames in an outer join to look at data more broadly. Another technique that is useful in this exercise is the to_datetime() method in pandas. After exploring the data, we can see that the date column is a listed as a string object, which is not suitable for plotting temporal data. This method then allows us to use set_index() to the date. The last step before plotting is crucial to our analysis and visualization because we do not want to see every single date object in the dataframe. Instead, we can use the rolling() method to specify that we want to take the rolling average over five days. In order to do this, we must select the column that holds the air quality data, aqi and apply the rolling() method, passing in the argument for 5 days. We can then specify that we want to take the mean().\nDataset descriptions: I am using the Air Quality Index (AQI) from the Environmental Protection Agency to visualize the impact on the AQI of the 2017 Thomas Fire in Santa Barbara County.\nLink to Github repository:\nFirst step is importing our packages and reading in our data. I am downloading the 2017 and 2018 CSVs from the EPA official website using the pandas function read_csv() from our data folder. os allows us to see the file path for reproducibility.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport os \n\n# Read in data\naqi_17 = pd.read_csv(os.path.join('data','daily_aqi_by_county_2017.csv'))\naqi_18 = pd.read_csv(os.path.join('data','daily_aqi_by_county_2018.csv'))\n\nGreat! Now, it is important that we combine the data using the concat() method. This allows the two dataframes to be concatenated into one dataframe, which we are going to call aqi. The next step includes cleaning the names into snake_case. How we do this is by selecting the columns, appending this with str.lower() to put every. columns into lowercase. The final step of this code is replacing the spaces with underscores, using str.replace(). Once this is done, all of the columns will be in tidy format.\n\n# Join the data frames, default outer join\naqi = pd.concat([aqi_17, aqi_18])\n\n# Simplify column names to snake_case (lowercase, replace spaces with underscore)\naqi.columns = (aqi.columns\n                  .str.lower()\n                  .str.replace(' ','_'))\n\nFor the AQI data, we want to only look at Santa Barbara. In order to do so, we must subset areas within the county_name column where it equals Santa Barbara. We can create a new dataframe with these values. Perfect, now we know that we are looking only at Santa Barbara County, so we can drop the other location indicators like state_name, county_name, state_code, and county_code. We can simply pass this list of column names into the drop() method. We must specify that axis = 1, explicitly telling the method that the axis is the columns. For reference, axis = 0 refers to rows, and axis = 1 refers to columns in this method.\n\n# Find all the observations with the county of Santa Barbara and put it into new dataframe \naqi_sb = aqi[aqi['county_name'] == 'Santa Barbara']\n# Remove columns indicated by column labels and axis\naqi_sb = aqi_sb.drop(['state_name', 'county_name', 'state_code', 'county_code'], axis = 1)\n\nPerfect! We are one step closer to plotting. What we want to do is look at the air quality index over time from 2017 to 2018, however the issue is that the actual date column contains strings at its current state. Moreover, we must convert it to a datetime object! When working with temporal data, it is super important to put our dates into this format for ease of plotting and data aggregation. We can just specify the column of the dataframe. To take this even further, we can now set the index as the date, which will be ordered from the beginning of the 2017 data to the end of 2018. Pretty cool!\n\n# Specify that we want to convert the date column to a date time object. \naqi_sb.date = pd.to_datetime(aqi_sb['date'])\n# Recall the dataframe with the function set_index and pass in date column to make the dates the new index\naqi_sb = aqi_sb.set_index('date')\n\nNow it gets a little crazy. It is not always the most visually pleasing to look at the daily AQI data, as it may start to look a little chaotic. In order to account for the amount of data we are dealing with, we can take the rolling average over every 5 days within the time period. The idea is we want to see the rolling average overlaid with the daily object.\nThis is when the rolling() function comes in. Specifying the values of the AQI column, we are able to pass 5D as an argument because we converted the date to our index as a datetime object. Now all there is to do calculate the mean() of each value in the Series. We can assign this list to a variable, which we can then further initialize a column with this assigned series called five_day_average\n\n# Calculate AQI rolling average over 5 days\nrolling_average = aqi_sb['aqi'].rolling('5D').mean()\n# Modify and create new column five day average that lines up with the rolling average object. Check to verify.\naqi_sb['five_day_average'] = rolling_average\n\nNow that all those steps are out of the way, we can plot!\n\n# Declare fig size so that positioning is clear for labels and captions\nplt.figure(figsize = (10,8))\n\n# Plot both the daily and five day averages for AQI\nplt.plot(aqi_sb.index.values, \n        aqi_sb['aqi'],\n       color = 'brown')\nplt.plot(aqi_sb.index.values,\n        aqi_sb['five_day_average'],\n        color = 'darkblue')\nplt.xticks(rotation = 30)                 # Rotate xticks so that all dates fit on x axis\nplt.xlabel('Date')                      \nplt.ylabel('AQI')\nplt.title('Santa Barbara Air Quality Index from 2017-2018')\nplt.figtext(0.5, -0.001, 'Daily average AQI is noted in brown. The five day rolling average is shown in blue.', wrap=True, horizontalalignment='center', fontsize=8)\n\nText(0.5, -0.001, 'Daily average AQI is noted in brown. The five day rolling average is shown in blue.')"
  },
  {
    "objectID": "posts/thomas-fire-exercises.html#exercise-2-false-color-imaging-of-thomas-fire",
    "href": "posts/thomas-fire-exercises.html#exercise-2-false-color-imaging-of-thomas-fire",
    "title": "Environmental Impacts of the 2017 Thomas Fire",
    "section": "Exercise 2: False Color Imaging of Thomas Fire",
    "text": "Exercise 2: False Color Imaging of Thomas Fire\nPurpose: This notebook aims to use the landsat raster data of Santa Barbara County and create a false color map image with the Thomas Fire boundary.\nHighlights: A highlight of this exercise was using a NetCDF dataset and dropping the band dimension. Another highlight was subsetting the variables to create a true color image and learning to account for sensitive outliers that may not show up due to cloud coverage. Moreover, using the robust=True argument with both the true color image and false color image was a key step for this. Reprojecting the CRS of both the Thomas Fire boundary and the landsat data was crucial to mapping.\nDataset Description: The dataset is from a California fire perimeter database from Data.gov. The landsat data is Landsat Collection 2 Level-2 atmosperically corrected surface reflectance data, collected by the Landsat 8 satellite. This data was pre-processed to remove data outside land and coarsen the spatial resolution.\nReferences:\nMicrosoft Planetary Computer. (n.d.). https://planetarycomputer.microsoft.com/dataset/landsat-c2-l2\nPublisher CAL FIRE. (2024, May 14). State of California - California Fire Perimeters (all). Catalog. https://catalog.data.gov/dataset/california-fire-perimeters-all-b3436\nIn our data folder, we have our landsat data that we will be using to create a visualization of Santa Barbara County. We also created a shapefile of the Thomas Fire boundary that we will later overlay on top of the landsat image. The goal here is to use the landsat data and create a false color image to highlight changes indicated by the Thomas Fire boundary.\n\nimport pandas as pd\nimport os\nimport numpy as np\nimport xarray as xr\nimport rioxarray as rioxr\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nfrom shapely.geometry import box\n\npd.set_option('display.max_columns', None) \n\nRead in our data!\n\n# Filepath using OS for reproducibility\nlandsat_df = rioxr.open_rasterio(os.path.join('data', \n                                             'landsat8-2018-01-26-sb-simplified.nc'))\n\n# Read in thomas boundary shapefile\nthomas_boundary = gpd.read_file(os.path.join('data', \n                                    'thomas_fire.shp'))\n\n\nPreliminary Landsat Data Exploration\nThe landsat data is an xarray.Dataset with 3 dimensions: band, x, and y. The band dimension has a length of 1 while both the x and y dimensions have lengths of 5. The data variables each show a different pieces that make up the false color imagery including, red, green, blue, nir08 (near infrared, and swir (shortwave infrared). The CRS is EPSG 32611.\n\n\nWrangle Band Data\nAs we discovered in our preliminary data exploration, the landsat_df is not exactly a dataframe. This object is a NetCDF created with a Rioxarray. There are elements to this that make the landsat data unfit for visualization, so we must wrangle the data to get it in the proper format for false color imaging.\n\n# Drop the band dimension of the data\nlandsat_df = landsat_df.squeeze().drop_vars('band')\n\nsqueeze() is a method that removes all dimensions of the NetCDF with a length of 1. In this case, the band dimension is a length of 1. The drop_vars() method specifies which element we want to remove, and returns the result rioxarray. I then called the dataset as a checkpoint to ensure the functions performed how I intended. Now that the band has been dropped, we can now start to visualize by selecting groups of the electromagnetic spectrum that are used in remote sensing.\n\n\nTrue Color Image\n\n# Select red, green, and blue variables into an array and plot\nlandsat_df[['red', 'green', 'blue']].to_array().plot.imshow()\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n\n\n\n\n\n\n\nWhat we see here is a sort of aggregated summary of the landsat data that excludes outlying values in our spectral bands. The clouds act as a barrier between the land cover and the satellite, so we cannot see the true color image. The RGB values were outliers, allowing the image to be squished into what looks like a blank outline of the land area. In the second output, using the robust=True argument adjusts the scale to be more sensitive to outliers, giving us the true RGB image. The next step is to select short infrared, near infrared, and red bands for false color imaging. Voila!\n\n# Robust parameters resolve the cloud cover issue\nlandsat_df[['red', 'green', 'blue']].to_array().plot.imshow(robust=True)\n\n\n\n\n\n\n\n\n\n\nFalse Color Image\nNow, what we notice about the True Color Image is it does not show subtle changes in the land use due to the bands we selected. False color imaging allows us see these differences more clearly. We can select the short infrared, near infrared, and red spectral bands. Can you guess where the fire happened?\n\n# Select short infrared, near infrared, and red bands to plot\n# Make plot sensitive to outliers with robust = True\nlandsat_df[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True)\n\n\n\n\n\n\n\n\n\n\nMap Thomas Fire Perimeter\nNow, we can overlay our Thomas Fire boundary shapefile with our false imaging. For geospatial data, we must make sure the projections align. I have created a conditional check for the coordinate reference systems. If the thomas boundary and landsat coordinate reference systems are not the same, then the code will reproject both to EPSG:4326 for uniformity.\n\n# Check to make sure CRS's match, if not reproject\nif thomas_boundary.crs != landsat_df.rio.crs:\n    thomas_boundary= thomas_boundary.to_crs(\"EPSG:4326\")\n    landsat_df = landsat_df.rio.reproject(\"EPSG:4326\")\n\nPerfect! We are now ready to plot. We can plot our thomas boundary on the same axes as the false color image. We can adjust the boundary polygon attributes like color and linewidth how it seems fit.\n\n# Set fig and axes\nfig, ax = plt.subplots(figsize = (8,8))\n\n# Select bands and plot false color\nlandsat_df[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust = True)\n\n# Plot boundary on the same axes, label the legend \nthomas_boundary.boundary.plot(ax = ax,\n                             color = '#E9190F',\n                             label = 'Thomas Fire Boundary',\n                             linewidth = 2)\n# Show legend\nax.legend()\n\n# Label Title and Axes for cleanliness\nax.set_title(\"False Color Map of California Thomas Fire in 2017\", fontsize=14, fontweight='bold')\nax.set_xlabel('X Coordinate of Projection (m)')\nax.set_ylabel('Y Coordinate of Projection (m)')\n\nText(44.847222222222214, 0.5, 'Y Coordinate of Projection (m)')\n\n\n\n\n\n\n\n\n\n\n\nFigure Description\nThe map above shows a false color image of the land burned by the Thomas Fire in California and surrounding areas. The boundary of the 2017 Thomas Fire is indicated by the red outline on the map. The false color image utilizes the short inrared, near infrared, and red bands in the electromagnetic spectrum to visualize changes in vegetation. Furthermore, the false color imaging shows the secondary succession within the Thomas Fire boundaries, that would not be otherwise noticeable with a True Color Imaging technique. Using this false color, the difference between the land outside of the burned areas is starkly indicated by the green color."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Nature, community, and collaboration. I possess a growth mindset to develop practical solutions through a unique approach involving outreach, education, data analysis, and science communication. I believe in reaching beyond barriers and connection to foster productive learning environments. My vision is to work with local governments to create equitable solutions necessary to meet goals in natural resource management."
  },
  {
    "objectID": "about.html#what-inspires-me",
    "href": "about.html#what-inspires-me",
    "title": "About",
    "section": "",
    "text": "Nature, community, and collaboration. I possess a growth mindset to develop practical solutions through a unique approach involving outreach, education, data analysis, and science communication. I believe in reaching beyond barriers and connection to foster productive learning environments. My vision is to work with local governments to create equitable solutions necessary to meet goals in natural resource management."
  },
  {
    "objectID": "about.html#what-im-working-on",
    "href": "about.html#what-im-working-on",
    "title": "About",
    "section": "What Iâ€™m working on",
    "text": "What Iâ€™m working on\nIâ€™m working locally to achieve SB 1383 goals in the unincorporated Santa Barbara County while completing my Masterâ€™s degree. In my academics, I am working on geospatial analyses, statistics, and visualization for environmental data.\nPreviously, I was an environmental educator for a nonprofit in San Diego, delivering presentations and assemblies to students of all ages. These presentations covered topics such as watershed pollution prevention, the role of sea otters within kelp forest ecosystems, food waste, and household hazardous waste."
  },
  {
    "objectID": "about.html#what-is-sb-1383",
    "href": "about.html#what-is-sb-1383",
    "title": "About",
    "section": "What is SB 1383?",
    "text": "What is SB 1383?\nCalifornia State Bill 1383 calls for a 75% reduction statewide in disposal of organic waste by 2025. I work for the County of Santa Barbara Public Works Department in the Resource Recovery and Waste Management Division, working to meet these goals. SB 1383 also madates that 20% of disposed edible food be recovered by 2025. This means all hands on deck! Counties across the state are working to divert organic waste through green bins, recycled food programs, educational presentations in schools, and much, much, more.\nBusiness, residents, and waste haulers are all doing our part to divert our organic waste. Find out more here."
  }
]